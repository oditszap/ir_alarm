//---*---+-+-+-+---*---+-+-+-+---*---+-+-+-+---*---+-+-+-+---*---+-+-+-+---*---+-+-+-+---*---+-+-+-+---*---+-+-+-+---//
//使用方法:
//1: 初始化: 按照PWM方式初始化,输出时开蜂鸣音
//2: 定义:   包括<音符定义>  <口线定义>  <周期数组>  <音乐数据表>
//3: 因为不同的振荡源频率不同,分频系数不同,则需要改变音符对应的周期,则直接修改<<单片机音乐蜂鸣用频率 周期关系表.xls>>
//		中对应变量即可,然后把结果复制到周期数组即可
//4: 音乐编辑方法为: 第1字节为音符节拍数,单位为1/8节拍,如果一个音符为1拍,则数据为8,依此类推
//		第2字节为音符,对应1~7的低音(l1~l7) 中音(m1~m7) 高音(h1~h7),休止符为xz, 根据简谱或五线谱编辑即可
//5: 音乐选择通过Music_Select()实现, 音乐输出通过Musicing()实现,每10毫秒调用一次.
//6: buzstp为一个标志,musicing()函数只清这标志,置位由使用程序完成
//7: 原来事业部使用的旧的音乐,不是标准的音符,所以设置单独的程序,选择音乐后,必须设置music_sel_ts_flg=1;,设置标准程序,无需清0
//8: 如果需要在两个音符间插入间隔,则需要设置休止符,休止符输出频率为前面一个频率,但节拍关闭
//---*---+-+-+-+---*---+-+-+-+---*---+-+-+-+---*---+-+-+-+---*---+-+-+-+---*---+-+-+-+---*---+-+-+-+---*---+-+-+-+---//

//本程序为完全我自己写的音乐蜂鸣程序，分成两种情况，第1种是单字节表示频率，另一种是双字节表示频率
//分别对应8位PWM和16位PWM，
//对于8位PWM，如果输入频率是8M，64分频后，可以满足最低490HZ，最高125KHZ的情况
//对于16位PWM，如果输入频率是8M，不分频，可以满足最低122HZ，最高8MHZ的情况，即使输入频率16M，仍然可以实现
//低音Do（262HZ）的发音，而且发音频率准确

//音乐存放格式为：
//音乐组织以每分88拍(考虑计算方便,取每分钟93拍,即每拍640毫秒)为基准,4分音符为一拍,也就是一拍为640毫秒,
//存放以1/8拍为单位,即以80毫秒为单位存放节拍长度
//第1字节为长度, 存放以1/8拍为单位,最多可以存放32拍,实际存放4拍即可,保留最高3个位
//第2字节为音符,分别按照下面的定义给出, 另建一个数组, 存放各音符频率对应的PWM周期值
//这个周期值将建立一个EXCEL 表, 只需填入PWM信号源频率 分频值即可得到.
//考虑有的单片机只有8位PWM,则建立两种表,分别针对8位PWM和16位PWM
//音乐中,0为休止符,则实际程序将发出战况比为100%的信号.

//特殊音乐选择
#define MF2591	1
#define MF2165	2
#define MF2220	3
#define MF2294	4
#define MF2370	5
#define MF2427	6
#define MF2525	7
#define MF2564	8
#define MFPWON	9		//开机
#define MFSTRT	10		//启动
#define MFPASU	11		//暂停
#define MFERRO	12		//故障
#define MFNWTR	13		//无水检测
#define MFZHQI	14		//周期检测
#define MFSELF	15		//音乐自检
#define MFEND	16		//结束
#define MFPOFF	17		//关机
#define MF2304	18


//音符定义
#define xz  0	//休止符
#define l1  1	//低音 1
#define l2  2	//低音 2
#define l3  3	//低音 3
#define l4  4	//低音 4
#define l5  5	//低音 5
#define l6  6	//低音 6
#define l7  7	//低音 7
#define m1  8	//中音 1
#define m2  9	//中音 2
#define m3  10	//中音 3
#define m4  11	//中音 4
#define m5  12	//中音 5
#define m6  13	//中音 6
#define m7  14	//中音 7
#define h1  15	//高音 1
#define h2  16	//高音 2
#define h3  17	//高音 3
#define h4  18	//高音 4
#define h5  19	//高音 5
#define h6  20	//高音 6
#define h7  21	//高音 7


//特殊频率音乐处理用定义,编写时直接写Y+频率值即可,简单方便
#define Y1543 1
#define Y1572 2
#define Y1736 3
#define Y1760 4
#define Y1838 5
#define Y1968 6
#define Y2049 7
#define Y2066 8
#define Y2092 9
#define Y2128 10
#define Y2165 11
#define Y2220 12
#define Y2228 13
#define Y2232 14
#define Y2242 15
#define Y2294 16
#define Y2304 17
#define Y2310 18
#define Y2347 19
#define Y2370 20
#define Y2404 21
#define Y2415 22
#define Y2427 23
#define Y2463 24
#define Y2525 25
#define Y2564 26
#define Y2577 27
#define Y2591 28
#define Y2604 29
#define Y2632 30
#define Y2732 31
#define Y2740 32
#define Y2809 33


//8位PWM 对应的周期值
//const unsigned char pwm8b_mc[]={0,239,216,190,179,159,142,127,120,106,95,89,80,71,63,60,53,47,45,40,36,32};
const unsigned char pwm8b_mc[]={0,120,106,95,89,80,71,63,60,53,47,45,40,36,32,30,27,24,22,20,18,16,};

//16位PWM 对应的周期值--高字节在前
const unsigned char pwm16b_mc[]={0,0,59,192,54,17,47,108,44,197,39,220,35,131,31,161,
29,224,26,153,23,182,22,95,19,238,17,193,15,209,14,240,13,76,11,219,11,47,9,247,8,225,7,232};
//10位PWM 对应的周期值--高字节在前
const unsigned char pwm10b_mc[]={0,0,3,188,3,97,2,247,2,204,2,126,2,56,1,250,
1,222,1,170,1,123,1,102,1,63,1,28,0,253,0,239,0,213,0,190,0,179,0,159,0,142,0,127};

//分别对应频率为 
//  Y1  Y2   Y3   Y4   Y5   Y6   Y7   Y8   Y9   Y10  Y11  Y12  Y13  Y14  Y15  Y16  Y17  Y18  Y19  Y20  Y21
//1572 1760 1968 2049 2092 2128 2165 2220 2228 2232 2242 2294 2304 2310 2347 2370 2404 2415 2427 2463 2525 
// Y22  Y23  Y24  Y25  Y26  Y27  Y28  Y29 
//2564 2577 2591 2604 2632 2732 2740 2809  的PWM值   Y0为0
const unsigned char pwm8b_ts[]={0,81,80,72,71,68,64,61,61,60,59,58,56,56,56,56,54,54,54,53,53,52,52,52,51,50,49,49,48,48,47,46,46,44};


//音乐输出方式: 
//  读出第1字节,确定音乐长度,读出第2字节为对应音符 .
//  第1字节低5位乘以8送计时器,用于计时,计时单位为10毫秒
//  第2字节再查表pwm8b_mc[]或pwm10b_mc[]或pwm16b_mc[],查出对应PWM周期值,送PWM周期寄存器.
//给出音乐表头地址的同时,给出该节音乐的音符数量,也可以直接使用SIZE OF ()伪指令取得长度,除以2即为音符数量.

/***********************************************************************/
/*                                                                     */
/*  FILE        :MYMUSIC.c                                               */
/*  DATE        :Fri, Aug 26, 2005                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :H8/36014F                                             */
/*                                                                     */
/*  This file is generated by Hitachi Project Generator (Ver.2.1).     */
/*                                                                     */
/***********************************************************************/
                  

#define uchar 		     unsigned char
#define uint		     unsigned int

void ini_pp(void);
void emi_p(void);
void ini_ram(void);
void delayus(uchar dlt);
void Buzzing(void);
void Music_Select(void);
void Musicing(void);


#include "iodefine.h"
#include <machine.h>

//-----------------------------------------------------------------
#define passz_kx	IO.PDR1.BIT.B7	//过零口线

#define Buzzeron()       	 TV.TCSRV.BIT.OS=6;
#define Buzzeroff()       	 TV.TCSRV.BIT.OS=0;

#define RESET_WATCHDOG() {WDT.TCSRWD.BIT.B6WI=0; WDT.TCSRWD.BIT.TCWE=1; WDT.TCWD=0x00; WDT.TCSRWD.BIT.TCWE=0; WDT.TCSRWD.BIT.B6WI=1;}

#define PORT1	IO.PDR1.BYTE
#define PORT2	IO.PDR2.BYTE
#define PORT5	IO.PDR5.BYTE
#define PORT7	IO.PDR7.BYTE
#define PORT8	IO.PDR8.BYTE
#define PORTB	IO.PDRB.BYTE

#define portmr1	IO.PMR1.BYTE
#define portmr5	IO.PMR5.BYTE

#define portcr1	IO.PCR1
#define portcr2	IO.PCR2
#define portcr5	IO.PCR5
#define portcr7	IO.PCR7
#define portcr8	IO.PCR8

#define portur1	IO.PUCR1.BYTE
#define portur5	IO.PUCR5.BYTE


//-----------------------------------------------------------------

union
{
unsigned char STAFLG;
struct {
    unsigned DYON_FLG:1;
    unsigned START_FLG:1;
    unsigned PAUSE_FLG:1;
    unsigned BOOK_FLG:1;
    unsigned :1;
    unsigned :1;
    unsigned HTTB:1;
    unsigned OPDR:1;
}STAFLGbits;
}STAFLGU;

#define staflg STAFLGU.STAFLG
#define dyonflg STAFLGU.STAFLGbits.DYON_FLG
#define startflg STAFLGU.STAFLGbits.START_FLG
#define pauseflg STAFLGU.STAFLGbits.PAUSE_FLG
#define bookflg STAFLGU.STAFLGbits.BOOK_FLG
	#define opendrflg STAFLGU.STAFLGbits.OPDR
	#define hurttbflg STAFLGU.STAFLGbits.HTTB


//////////////////////////有关定义开始//////////////////////////////////////

//-------------------- 位变量定义 --------------------
volatile union
{
	unsigned char BYTE;
	struct
	{
		unsigned S7:1;
		unsigned S6:1;
		unsigned S5:1;
		unsigned S4:1;
		unsigned S3:1;
		unsigned S2:1;
		unsigned S1:1;
		unsigned S0:1;
	}BIT;
}MFLGU;
	#define musicflg			MFLGU.BYTE
	#define mflg10ms			MFLGU.BIT.S7	//到达10毫秒标志,每10毫秒处理一次音乐
	#define buzstp				MFLGU.BIT.S6	//音乐输出停止标志 0:停止  1:正在输出  这个标志不在音乐丰满程序中置位,只清0
	#define musicruning			MFLGU.BIT.S5	//音乐是否正在输出  1:是  0:未
	#define music_1st_flg		MFLGU.BIT.S4	//重新设置了音乐后,初次进入音乐输出程序  1:否 0:初次进入
	#define music_sel_ts_flg	MFLGU.BIT.S3	//选择特殊音乐标志


//-------------------- 变量定义 --------------------
unsigned char btMusicSet;		//音乐选择
unsigned char music_pai_ct;		//音乐音符输出时间保存
unsigned char music_yinf_nu;		//音乐音符数量保存
unsigned char music_peri;		//读出的音符周期保存
unsigned char *music_ptr;		//音乐起始地址


//-------------------- 特殊功能寄存器定义 --------------------
#define pwm_period 		TV.TCORA		//周期
#define pwm_duty 		TV.TCORB		//占空比
#define jiepai_kx 		IO.PDR1.BIT.B2		//节拍控制

#define pwm_period_h 		TV.TCORA		//周期--高字节
#define pwm_period_l 		TV.TCORA		//周期--低字节
#define pwm_duty_h 		TV.TCORB		//占空比--高字节
#define pwm_duty_l 		TV.TCORB		//占空比--低字节

//////////////////////////有关定义结束//////////////////////////////////////

uchar jsq10ms;		//10毫秒计时用


//音乐存放格式为：
//音乐组织以每分88*2拍(考虑计算方便,取每分钟93*2拍,即每拍320毫秒)为基准,4分音符为一拍,也就是一拍为320毫秒,
//存放以1/8拍为单位,即以40毫秒为单位存放节拍长度
//第1字节为长度, 存放以1/8拍为单位,最多可以存放32拍,实际存放4拍即可,保留最高3个位
//第2字节为音符,分别按照下面的定义给出, 另建一个数组, 存放各音符频率对应的PWM周期值
//这个周期值将建立一个EXCEL 表, 只需填入PWM信号源频率 分频值即可得到.
//考虑有的单片机只有8位PWM,则建立两种表,分别针对8位PWM和16位PWM
//音乐中,0为休止符,则实际程序将发出战况比为100%的信号.

//-------------------- 音乐数据表 ------------------------------------------------------------
//My Bonnie
const unsigned char mybonie[]={8,l5,8,m3,8,m2,8,m1,8,m2,8,m1,8,l6,8,l5,8,l3,8,l3,8,l3,8,l3,8,l5,8,m3,8,m2,8,m1,8,m1,8,l7,8,m1,8,m2,8,m2,8,m2,
	8,m2,8,m2,8,l5,8,m3,8,m2,8,m1,8,m2,8,m1,8,l6,8,l5,8,l3,8,l3,16,l3,8,l5,8,l6,8,m2,8,m1,8,l7,8,l6,8,l7,8,m1,8,m1,8,m1};
//You are my sunshine
const unsigned char mysunshine[]={8,l5,8,m1,8,m2,16,m3,16,m3,16,m3,8,m2,8,m3,16,m1,16,m1,8,m1,8,m1,8,m2,8,m3,16,m4,
	16,m6,16,m5,8,m4,16,m3,16,m3,8,m3,8,m1,8,m2,8,m3,16,m4,16,m6,16,m6,8,m5,8,m4,16,m3,16,m1,24,m1,8,m2,24,m3,8,m4,
	24,m2,8,m3,32,m1,8,m1,8,l5,8,m1,8,m2,16,m3,16,m3,16,m3,8,m2,8,m3,32,m1,16,m1,8,m2,8,m3,16,m4,16,m6,16,m6,8,m5,8,m4,32,m3};
//铃儿响叮当
const unsigned char jingle_bell1[]=
{8,l5,8,m3,8,m2,8,m1,16,l5,8,0,4,l5,4,l5,
8,l5,8,m3,8,m2,8,m1,8,l6,8,l6,8,l6,8,0,
8,l6,8,m4,8,m3,8,m2,24,l7,8,0,
8,m5,8,m5,8,m4,8,m2,24,m3,8,0,
8,l5,8,m3,8,m2,8,m1,8,l5,8,l5,8,l5,8,0,
8,l5,8,m3,8,m2,8,m1,8,l6,8,l6,8,l6,8,l6,
8,l6,8,m4,8,m3,8,m2,8,m5,1,0,8,m5,1,0,8,m5,1,0,8,m5,
8,m6,8,m5,8,m4,8,m2,8,m1,24,0,

8,m3,1,0,8,m3,1,0,16,m3,1,0,8,m3,1,0,8,m3,1,0,16,m3,1,0,
8,m3,8,m5,12,m1,4,m2,24,m3,8,m3,
16,m4,1,0,12,m4,1,0,4,m4,1,0,8,m4,16,m3,4,m3,4,m2,
8,m3,8,m2,8,m2,8,m3,16,m2,16,m5,

8,m3,1,0,8,m3,1,0,16,m3,1,0,8,m3,1,0,8,m3,1,0,16,m3,1,0,
8,m3,8,m5,12,m1,4,m2,24,m3,8,m3,
16,m4,1,0,12,m4,1,0,4,m4,1,0,8,m4,16,m3,1,0,4,m3,1,0,4,m3,
8,m5,8,m4,8,m3,8,m2,32,m1,
};

//铃儿响叮当
const unsigned char jingle_bell2[]=
{
8,m3,1,0,8,m3,1,0,16,m3,1,0,8,m3,1,0,8,m3,1,0,16,m3,1,0,
8,m3,8,m5,12,m1,4,m2,24,m3,8,m3,
16,m4,1,0,12,m4,1,0,4,m4,1,0,8,m4,16,m3,1,0,4,m3,1,0,4,m3,
8,m5,8,m4,8,m3,8,m2,32,m1,
};

//新年快乐
const unsigned char happy_new_year[]=
{
8,m1,1,0,8,m1,8,l5,8,m3,1,0,8,m3,8,m1,4,m1,4,m3,8,m5,8,m5,
4,m4,4,m3,16,m2,4,m2,4,m3,16,m4,4,m3,4,m2,8,m3,8,m1,
4,m1,4,m3,8,m2,8,l5,4,l7,4,m2,16,m1
};


//GOOD NIGHT
const unsigned char good_night[]=
{
8,m5,8,m6,8,m4,16,m3,1,0,8,m3,8,m2,8,m1,8,l7,
16,m1,8,m3,8,m4,8,m3,8,m6,7,m5,1,0,7,m5,1,0,7,m5,1,0,
8,m4,8,m3,8,m2,16,m3,8,m1,1,0,16,m1,1,0,8,m1,1,0,
16,m1,1,0,8,m1,16,l5,1,0,8,l5,16,m1
};

//小小的船
const unsigned char small_boat[]=
{
8,h1,8,m7,8,h1,16,m6,8,m5,8,m4,8,m2,8,m6,24,m5,
16,m6,8,m5,8,m4,8,m2,8,m6,24,m4,8,m6,8,m5,8,m6,8,m4,1,0,8,m4,8,m2,8,m4,8,h1,8,m6,
24,m5,8,m6,8,m5,8,m6,8,h2,8,h3,8,h2,16,m6,8,m5,8,m4,8,m2,8,m4,24,m4
};

//蓝色多瑙河--调太高,难以播放
const unsigned char blue_danube[]=
{
8,m1,8,m3,8,m5,1,0,24,m5,1,0,24,m5,1,0,8,m5,8,0,8,m1,
8,m1,8,m3,8,m5,1,0,24,m5,1,0,24,m5,1,0,8,m5,8,0,8,l7,
8,l7,8,m2,8,m6,1,0,24,m6,1,0,24,m6,1,0,8,m6,8,0,8,l7,
8,l7,8,m2,8,m6,1,0,24,m6,1,0,24,m6,1,0,8,m6,8,0,8,m1,
8,m1,8,m3,8,m5,1,0,24,h1,1,0,24,h1,1,0,8,h1,8,0,8,m1,
8,m1,8,m3,8,m5,1,0,24,h1,1,0,24,h1,1,0,8,h1,8,0,8,m2,
8,m2,8,m4,8,m6,1,0,24,m6,1,0,8,m6,8,m4,8,m5,24,h3,
};

//致爱丽丝
const unsigned char to_anlice[]=
{
2,h3,2,h2,2,h3,2,h2,2,h3,2,h7,2,h2,2,h1,4,m6,2,0,2,m1,2,m3,2,m6,4,m7,2,0,2,m3,2,m5,2,m7,4,h1,
2,0,2,m3,2,h3,2,h2,2,h3,2,h2,2,h3,2,h7,2,h2,2,h1,4,m6,2,0,2,m1,2,m3,2,m6,4,m7,2,0,2,m3,2,h1,2,m7,4,m6,
2,0,2,m7,2,h1,2,h2,4,h3,2,0,2,m5,2,h4,2,h3,4,h2,2,0,2,m4,2,h3,2,h2,4,h1,2,0,2,m3,2,h2,2,h1,4,m7,
2,0,2,m3,2,h3,2,m3,2,h3,2,m3,2,m3,2,h2,2,h3,2,h2,2,h3,2,h2,2,h3,2,h2,2,h3,2,h2,2,h3,2,h2,2,h3,2,m7,2,h2,2,h1,4,m6,
2,0,2,m1,2,m3,2,m6,2,m7,2,0,2,m3,2,m5,2,m7,2,h1,2,0,2,m3,2,h3,2,h2,2,h3,2,m7,2,h2,2,h1,4,m6,
};


//回家
const unsigned char go_home[]=
{
8,0,8,0,4,m6,4,m5,1,m4,2,m3,1,m2,8,m1,1,0,7,m1,1,0,7,m1,1,0,7,m1,8,m1,1,0,7,m1,1,0,7,m1,8,0,
4,m2,4,m3,4,m3,4,m5,8,m5,8,0,4,m2,4,m3,4,m3,4,m5,8,m5,8,0,4,m5,4,m6,4,m6,2,m3,2,m1,4,m2,8,m2,1,0,7,m2,,1,0,7,m2,8,0,
4,m2,4,m3,4,m3,4,m5,8,m5,8,0,4,m2,4,m3,4,m3,4,m5,8,m5,8,0,4,m5,4,m6,4,m6,2,m3,2,m1,4,m2,8,m2,1,0,7,m2,,1,0,7,m2,4,m6,4,m7,
8,h1,4,m7,4,h1,4,h1,4,m6,4,m7,4,h1,8,h1,4,m7,4,h1,8,h1,2,0,2,m3,2,m6,2,m7,8,h1,2,m7,2,h1,4,h3,4,h3,4,h2,4,h1,4,m7,8,m7,1,0,8,m7,4,0,4,m3,4,m6,4,m7,
8,h1,4,m7,4,h1,4,h1,4,m6,4,m7,4,h1,8,h1,4,m7,4,h1,8,h1,2,0,2,m3,2,m6,2,m7,8,h1,2,m7,2,h1,4,h3,4,h3,4,h2,4,h1,4,m7,6,m2,2,m3,2,0,4,0,4,m3,4,m6,4,m7,
};

//以下为原来事业部使用的音乐数据,程序进行了单独的特殊处理
const unsigned char openbuz[]={10,Y2304,10,0,10,Y2463,10,0,10,Y2740,10,0};
const unsigned char closebuz[]={10,Y2304,10,0,10,Y2066,10,0,10,Y2304,10,0,10,Y1736,10,0,10,Y2066,10,0,10,Y1838,10,0,10,Y1543,10,0};
const unsigned char pausebuz[]=	{5,Y2732,15,0};
const unsigned char startbuz[]={5,Y2732,5,0,5,Y2564,5,0,5,Y2415,5,0,5,Y2310,5,0,5,Y2165,5,0};
const unsigned char endbuz[]=
	{10,Y1968,20,0,30,Y1572,20,0,10,Y1968,20,0,20,Y1572,15,0,5,Y1968,15,0,10,Y2347,15,0,10,Y2347,10,0,10,Y2092,10,0,10,Y1968,10,0,
10,Y1760,10,0,5,Y1572,10,0,5,Y1572,15,0};

const unsigned char errbuz[]=
{15,Y2732,10,0,15,Y2128,10,0,15,Y2732,10,0,15,Y2128,10,0,15,Y2732,10,0,15,Y2128,10,0,
15,Y2732,10,0,15,Y2128,10,0,15,Y2732,10,0,15,Y2128,10,0,15,Y2732,10,0,15,Y2128,10,0,
15,Y2732,10,0,15,Y2128,10,0,15,Y2732,10,0,15,Y2128,10,0,15,Y2732,10,0,15,Y2128,10,0,
15,Y2732,10,0,15,Y2128,10,0,15,Y2732,10,0,15,Y2128,10,0,15,Y2732,10,0,15,Y2128,10,0,
15,Y2732,10,0,15,Y2128,10,0,15,Y2732,10,0,15,Y2128,10,0,15,Y2732,10,0,15,Y2128,10,0,};

const unsigned char testbuz[]=
{5,Y2128,5,Y2242,5,0,5,Y2228,5,0,5,Y2564,5,0,5,Y2732,5,0,5,Y2294,5,0,5,Y2415,5,0,
5,Y2463,5,0,5,Y2347,5,0,5,Y2092,5,0,5,Y1968,5,0,5,Y2165,5,0,5,Y2128,5,0,
5,Y2049,5,0,5,Y2525,5,0,5,Y2604,5,0,5,Y2809,5,0,5,Y2404,5,0,5,Y2577,5,0,5,Y2632,5,0,5,Y2347,5,0,5,
Y2242,5,0,5,Y1968,5,0,5,Y2232,5,0,5,Y2128,5,0,5,Y2809,5,0};

const unsigned char lastbuz[]={5,Y2304,5,0,5,Y2463,5,0};

const unsigned char nwbuz[]={5,Y2732,5,0,5,Y2732,5,0};

const unsigned char lkeybuz[]={10,Y2304,10,0};

const unsigned char mf2591[]={5,Y2591,15,0};
const unsigned char mf2220[]={5,Y2220,15,0};
const unsigned char mf2165[]={5,Y2165,15,0};
const unsigned char mf2294[]={5,Y2294,15,0};
const unsigned char mf2370[]={5,Y2370,15,0};
const unsigned char mf2732[]={5,Y2732,15,0};
const unsigned char mf2427[]={5,Y2427,15,0};
const unsigned char mf2525[]={5,Y2525,15,0};
const unsigned char mf2564[]={5,Y2564,15,0};


//-------------------- 音乐数据表--结束 ------------------------------------------------------------

#ifndef PWM8B_CM
#define PWM8B_CM
#endif


//-----------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif
void abort(void);
#ifdef __cplusplus
}
#endif

void main(void)
{
uchar lst1;
	nop();
	nop();
main_1:
	ini_ram();	//RAM初始化,主要写入0外的数据
	ini_pp();	//端口及外围功能初始化
	lst1=200;
	for(;;) 
	{
main_2:
		emi_p();
main_6:
		RESET_WATCHDOG(); 
		if (!mflg10ms) goto main_2;
		mflg10ms=0;
		lst1++;

		if (!buzstp)
		{
			if (lst1>=200)
			{
//				btMusicSet=MFSELF;
//				music_sel_ts_flg=1;
				btMusicSet=8;
				buzstp=1;
			}
		}
		else lst1=0;

		Music_Select();
		Musicing();
	}
}





//------******---START---******---音---******---乐---******---程---******---序---******---START---******------//
//音乐选择
//如果选择特殊音乐,则设置btMusicSet后,需要同时设置music_sel_ts_flg=1
void Music_Select(void)
{
	if (btMusicSet==0) return;
	if (!music_sel_ts_flg) goto Music_sel2;
	switch(btMusicSet)
	{
		case MF2591:	
			music_ptr=mf2591;
			music_yinf_nu=(sizeof(mf2591))/2;
			break;
		case MF2165:	
			music_ptr=mf2165;
			music_yinf_nu=(sizeof(mf2165))/2;
			break;
		case MF2220:
			music_ptr=mf2220;
			music_yinf_nu=(sizeof(mf2220))/2;
			break;
		case MF2294:	
			music_ptr=mf2294;
			music_yinf_nu=(sizeof(mf2294))/2;
			break;
		case MF2370:
			music_ptr=mf2370;
			music_yinf_nu=(sizeof(mf2370))/2;
			break;
		case MF2427:
			music_ptr=mf2427;
			music_yinf_nu=(sizeof(mf2427))/2;
			break;
		case MF2525:
			music_ptr=mf2525;
			music_yinf_nu=(sizeof(mf2525))/2;
			break;
		case MF2564:
			music_ptr=mf2564;
			music_yinf_nu=(sizeof(mf2564))/2;
			break;
		case MFPWON:
			music_ptr=openbuz;
			music_yinf_nu=(sizeof(openbuz))/2;
			break;
		case MFSTRT:
			music_ptr=startbuz;
			music_yinf_nu=(sizeof(startbuz))/2;
			break;
		case MFPASU:
			music_ptr=pausebuz;
			music_yinf_nu=(sizeof(pausebuz))/2;
			break;
		case MFERRO:
			music_ptr=errbuz;
			music_yinf_nu=(sizeof(errbuz))/2;
			break;
		case MFNWTR:
			music_ptr=nwbuz;
			music_yinf_nu=(sizeof(nwbuz))/2;
			break;
		case MFZHQI:
			music_ptr=lastbuz;
			music_yinf_nu=(sizeof(lastbuz))/2;
			break;
		case MFSELF:
			music_ptr=testbuz;
			music_yinf_nu=(sizeof(testbuz))/2;
			break;
		case MFEND:
			music_ptr=endbuz;
			music_yinf_nu=(sizeof(endbuz))/2;
			break;
		case MFPOFF:
			music_ptr=closebuz;
			music_yinf_nu=(sizeof(closebuz))/2;
			break;
		case MF2304:
			music_ptr=lkeybuz;
			music_yinf_nu=(sizeof(lkeybuz))/2;
			break;
		default:
			break;
	}

	goto Music_sel1;
Music_sel2:
	switch (btMusicSet)
	{
		case 1:
			music_ptr=mybonie;
			music_yinf_nu=(sizeof(mybonie))/2;
			break;
		case 2:
			music_ptr=mysunshine;
			music_yinf_nu=(sizeof(mysunshine))/2;
			break;
		case 3:
			music_ptr=jingle_bell1;
			music_yinf_nu=(sizeof(jingle_bell1))/2;
			break;
		case 4:
			music_ptr=jingle_bell2;
			music_yinf_nu=(sizeof(jingle_bell2))/2;
			break;
		case 5:
			music_ptr=blue_danube;
			music_yinf_nu=(sizeof(blue_danube))/2;
			break;
		case 6:
			music_ptr=happy_new_year;
			music_yinf_nu=(sizeof(happy_new_year))/2;
			break;
		case 7:
			music_ptr=good_night;
			music_yinf_nu=(sizeof(good_night))/2;
			break;
		case 8:
			music_ptr=small_boat;
			music_yinf_nu=(sizeof(small_boat))/2;
			break;
		case 9:
			music_ptr=happy_new_year;
			music_yinf_nu=(sizeof(happy_new_year))/2;
			break;
		case 10:
			music_ptr=happy_new_year;
			music_yinf_nu=(sizeof(happy_new_year))/2;
			break;
		default:
			break;
	}
Music_sel1:
	musicruning=1;
	btMusicSet=0;
	music_1st_flg=0;
	Buzzeron();

}

//音乐输出
void Musicing(void)
{
	if (!musicruning)
	{
		jiepai_kx=0;	//停止输出
		buzstp=0;
		return;
	}
	if (music_pai_ct==0)
	{//当前拍输出完毕
		if (music_yinf_nu!=0) 
		{//下一个音符
			music_yinf_nu--;
			music_pai_ct=*music_ptr;	//该音符输出长度
			music_pai_ct&=0x1f;
			if (!music_sel_ts_flg) music_pai_ct*=4;
			music_ptr++;
			music_peri=*(music_ptr);
			if (music_peri==xz) 
			{
				music_peri=*(music_ptr-2);
				jiepai_kx=0;
			}
			else jiepai_kx=1;
			music_ptr++;

			#ifdef PWM8B_CM
			if (music_sel_ts_flg)
			{
				music_peri=pwm8b_ts[music_peri];
				pwm_period=music_peri;
				pwm_duty=music_peri/2;
			}
			else
			{
				music_peri=pwm8b_mc[music_peri];
				pwm_period=music_peri;
				pwm_duty=music_peri/2;
			}
			#endif

			#ifdef PWM10B_CM
			ls1=pwm10b_mc[music_peri*2];
			ls2=pwm10b_mc[music_peri*2+1];
			pwm_period_h=ls1;
			pwm_period_l=ls2;
			pwm_duty_h=ls1/2;
			pwm_duty_l=ls2/2;
			#endif

			#ifdef PWM16B_CM
			ls1=pwm16b_mc[music_peri*2];
			ls2=pwm16b_mc[music_peri*2+1];
			pwm_period_h=ls1;
			pwm_period_l=ls2;
			pwm_duty_h=ls1/2;
			pwm_duty_l=ls2/2;
			#endif
		}
		else
		{//音乐输出完毕
			musicruning=0;
			buzstp=0;
			jiepai_kx=0;
			music_sel_ts_flg=0;
			return;
		}
	}
	if (music_pai_ct!=0)	
	{
		music_pai_ct--;
	}
}



//------******---END---******---音---******---乐---******---程---******---序---******---END---******------//


void pPIT_ISR_P (void)
{
	//1毫秒
	TW.TSRW.BYTE&=0x7f;
	TW.TCNT=57536;		//1毫秒
	jsq10ms++;
	if (jsq10ms>=10)
	{
		jsq10ms=0;
		mflg10ms=1;
//		lsct++;
	}
}






//----------------------------------------------------------------------//
//内部RAM初始化程序,														//
//从00~1ff全部清0
//----------------------------------------------------------------------//
void ini_ram(void)
{
uint *p;
uint i;
	p=&STAFLGU;
	for (i=0;i<400;i++)
	{
		*p=0;
		p++;
	}
}



//----------------------------------------------------------------------//
//内部外围功能初始化--为抗干扰, 再处理
//----------------------------------------------------------------------//
void emi_p(void)
{
	portcr1 =0x67;	//0b01100111;	//方向
	portcr2 =0x07;	//0b00000111;	//方向
	portcr5 =0xff;	//0b11111111;	//方向
	portcr7 =0x59;	//0b01011001;	//方向
	portcr8 =0x0f;	//0b00001111;	//方向
}


//----------------------------------------------------------------------//
void ini_pp(void)
{
	portmr1 =0x08;	//0b00001000;	// TXD2
	PORT1 =0x98;	//0b10011000;
	portur1=0x00;	//0b00000000;

	PORT2 =0x00;	//0b00000000;

	portmr5 =0x00;	//0b00000000;	//为普通IO
	PORT5 =0xc0;	//0b11000000;
	portur5=0x00;	//0b00000000;

	PORT7 =0x16;	//0b00010110;

	PORT8 =0x07;	//0b00000111;

	emi_p();

//TIMERV初始化
//计数模式,水位处理
//	TV.TCNTV=0;
//	TV.TCRV0.BYTE=0x05;	//0b00000101	//外部脉冲--计数模式


//TIMERV初始化
//输出2.5K频率 驱动蜂鸣器
	TV.TCNTV=0;
	TV.TCRV0.BYTE=0x0b;	//0b00001011;	//与A匹配 计数器清0  输入脉冲为1/64振荡频率
//	TV.TCRV1.BIT.ICKS=1;
	TV.TCORA=0xFF;			//2.5K比较常数
	TV.TCORB=0xFF;			//在50%时与B比较匹配, 则获得了50%占空比

/*
//TIMERV初始化
//定时1毫秒中断
	TV.TCNTV=0;
	TV.TCRV0.BYTE=0x4a;	//01001010 与A匹配中断, 且清0
	TV.TCSRV.BYTE=0x10;	//00010000
	TV.TCRV1.BYTE=0xe3;	//11100011
	TV.TCORA=250;
*/


//TIMERW初始化
//定时1毫秒,用于显示扫描和定时计时
	TW.GRA=0xffff;
	TW.GRB=0xffff;
	TW.GRC=0xffff;
	TW.GRD=0xffff;
	TW.TCNT=57536;	//1毫秒						//25536;		//5毫秒
	TW.TIOR0.BYTE=0x88;	//0b10001000;
	TW.TIOR1.BYTE=0x88;	//0b10001000;
	TW.TMRW.BYTE=0xc8;	//0b11001000;
	TW.TCRW.BYTE=0x80;	//0b10000000;
	TW.TSRW.BYTE=0x70;	//0b01110000
	TW.TIERW.BYTE=0xf0;	//0b11110000;
	TW.TMRW.BIT.CTS=1;	//START

/*
//TIMERW初始化
//外部脉冲测水位
	TW.GRA=0xffff;
	TW.GRB=0xffff;
	TW.GRC=0xffff;
	TW.GRD=0xffff;
	TW.TCNT=0;	//
	TW.TIOR0.BYTE=0x88;	//10001000;
	TW.TIOR1.BYTE=0x88;	//0b10001000;
	TW.TMRW.BYTE=0xc8;	//0b11001000;
	TW.TCRW.BYTE=0x40;	//0b01000000;	//外部脉冲
	TW.TSRW.BYTE=0x70;	//0b01110000
	TW.TIERW.BYTE=0x70;	//0b01110000;
	TW.TMRW.BIT.CTS=1;	//START
*/	

//ADC初始化
	AD.ADCSR.BYTE=0x03;	//00000011   单次模式 4通道
/*
//SCI--2 初始化
//9600BPS 1个起始  1个停止 无校验
	SCI3_2.SCR3.BYTE=0x00;
	SCI3_2.SMR.BYTE=0x00;	//00000000  1 开始  1结束  8数据 内部1:1 无校验
	SCI3_2.BRR=25;		//9600BPS
	delayus(120);
	SCI3_2.SSR.BYTE=(SCI3_2.SSR.BYTE|0x80)&0x80;
	SCI3_2.SCR3.BYTE=0x50;	//接收允许  发送禁止 接收中断允许  发送中断禁止
*/
//WDT初始化
//WDT时间为120毫秒
	WDT.TMWD.BYTE  =0x0e;	//0b00001110;	//时间常数 
	WDT.TCSRWD.BIT.B4WI=0;
	WDT.TCSRWD.BIT.TCSRWE=1;
	WDT.TCSRWD.BIT.WDON=1;		//WDT开启
	WDT.TCSRWD.BIT.TCSRWE=0;
	WDT.TCSRWD.BIT.B4WI=0;


//中断初始化
//  IRQ0中断  其它关闭
//	IENR1.BYTE=0x01;	//0b00000001;	IRQ3 disable  IRQ0 ENABLE
//	CCR.BIT.I=0;		//总中断允许
	set_imask_ccr(0);
}
